package net.xp_framework.build.subscriber;

import util.Properties;
import org.codehaus.stomp.StompConnection;
import io.streams.MemoryInputStream;
import webservices.rest.RestFormat;

/**
 * Abstract base class for all subscribers
 */
package abstract class AbstractSubscriber extends util.cmd.Command {
  private StompConnection $queue;
  private double $timeout;
  private string $origin;
  private string $destination;

  /**
   * Returns origin to use for messages
   */
  protected abstract string origin();

  /**
   * Returns destination to use for replies
   */
  protected abstract string destination();

  /**
   * Injects message queue configuration
   */
  [@inject(name = 'mq')]
  public void useMessageQueue(Properties $prop) {
    $this.queue= new StompConnection($prop.readString('endpoint', 'host'), $prop.readInteger('endpoint', 'port'));
    $this.queue.connect($prop.readString('endpoint', 'user'), $prop.readString('endpoint', 'pass'));
    $this.origin= $prop.readString('destinations', $this.origin());
    $this.destination= $prop.readString('destinations', $this.destination());
  }

  /**
   * Find handler method
   *
   * @return the method, or NULL if none is found
   */
  protected lang.reflect.Method findHandler() {
    foreach ($m in $this.getClass().getMethods()) {
      if ($m.hasAnnotation('handler')) return $m;
    }
    return null;
  }

  /**
   * Sets timeout. Defaults to 1 second, pass "-" for forever.
   */
  [@arg]
  public void setTimeout(string? $t= '1.0') {
    $this.timeout= null === $t ? null : $t as double;
  }

  /**
   * Listens
   */
  public int run() {
    $serializer= RestFormat::$JSON.serializer();

    // Create handler mapping
    if (!($handler= $this.findHandler())) {
      $this.err.writeLine('No handler method found in ', $this);
      return 1;
    }

    // Subscribe and listen
    $this.queue.subscribe($this.origin);
    $this.out.writeLinef(
      'Subscribed to %s using %s timeout',
      $this.origin,
      null === $this.timeout ? 'no' : $this.timeout ~ ' second(s)'
    );
    while ($message= $this.queue.receive($this.timeout)) {
      $this.err.writeLine('<<< ', $message);

      // Break on errors
      if ('MESSAGE' !== $message.command()) break;

      // Handle
      try {
        $response= $handler.invoke($this, [RestFormat::$JSON.read(
          new MemoryInputStream($message.getBody()),
          $handler.getParameter(0).getType()
        )]);
        if (null === $response) {
          $this.err.writeLine('+++');
        } else {
          $this.err.writeLine('>>> ', $response);
          $message= $serializer.serialize($response);
          $this.queue.send($this.destination, $message, [
            'content-type' : $serializer.contentType()
          ]);
        }
      } catch (lang.reflect.TargetInvocationException $e) {
        $this.err.writeLine('*** ', $e);
      }
    }
    $this.out.writeLine('Finished listening');
    return 0;
  }

  /**
   * Destructor. Closes connection to MQ
   */
  public void __destruct() {
    $this.queue.disconnect();
  }
}