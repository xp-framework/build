package net.xp_framework.build.api;

import webservices.rest.srv.Response;
import webservices.rest.RestFormat;
import util.log.LogCategory;
import util.Properties;
import io.streams.MemoryInputStream;
import org.codehaus.stomp.StompConnection;

import native standard.sscanf;

/**
 * Web hook to capture tag creation
 *
 */
[@webservice(path= '/hook')]
public class WebHook {
  private LogCategory $cat;
  private StompConnection $queue;
  private string $destination;

  /**
   * Sets a logger category for debugging
   */
  [@inject(name = 'trace')]
  public void setTrace(LogCategory $cat= null) {
    $this.cat= $cat;
  }

  /**
   * Injects message queue configuration
   */
  [@inject(name = 'mq')]
  public void useMessageQueue(Properties $prop) {
    $this.queue= new StompConnection($prop.readString('endpoint', 'host'), $prop.readInteger('endpoint', 'port'));
    $this.queue.connect($prop.readString('endpoint', 'user'), $prop.readString('endpoint', 'pass'));
    $this.destination= $prop.readString('queue', 'destination');
  }

  /**
   * Disconnects from queue
   */
  public void __destruct() {
    $this.queue.disconnect();
  }

  /**
   * GitHub passes a JSON string as value for the "payload" form variable
   *
   * @see https://help.github.com/articles/post-receive-hooks
   */
  [@webmethod(verb= 'POST', accepts= 'application/x-www-form-urlencoded'), @$in: param('payload')]
  public Response githubTrigger(string? $in) {
    try {
      $payload= RestFormat::$JSON.read(new MemoryInputStream($in), GitHubPayload::class) as GitHubPayload;
    } catch (FormatException $e) {
      return Response::error(400).withPayload('Malformed payload: ' ~ $e.compoundMessage());
    }

    // Created a tag -> trigger
    if ($payload.created && ($tag= $payload.getTag())) {
      sscanf($tag, 'r%[0-9A-Za-z.~]', $version);

      with ($serializer= RestFormat::$JSON.serializer()) {
        $message= $serializer.serialize([
          owner   : $payload.repository.owner.name,
          repo    : $payload.repository.name,
          tag     : $tag,
          version : $version,
          user    : $payload.pusher.name
        ]);
        $this.cat && $this.cat.info($this.destination, $message);
        $this.queue.send($this.destination, $message, [
          'content-type' : $serializer.contentType()
        ]);
      }
    } else {
      $this.cat && $this.cat.debug('Ignore', $payload);
    }

    return Response::created();
  }
}